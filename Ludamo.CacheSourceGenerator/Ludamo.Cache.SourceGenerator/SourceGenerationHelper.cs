using System;
using System.Text;

namespace Ludamo.Cache.SourceGenerator;

internal static class SourceGenerationHelper
{
    public const string AttributeNamespace = "Ludamo.Cache.SourceGenerator.CacheDecorated";
    public const string FullAttributeNamespace = "Ludamo.Cache.SourceGenerator.CacheDecoratedAttribute";
    public const string CacheDecoratedAttribute =
    """
        using System;

        namespace Ludamo.Cache.SourceGenerator;

        [AttributeUsage(AttributeTargets.Method)]
        public class CacheDecoratedAttribute : Attribute
        {
            public int? ExpiresInSeconds { get; }

            public CacheDecoratedAttribute()
            {
            }

            public CacheDecoratedAttribute(int expiresInSeconds)
            {
                ExpiresInSeconds = expiresInSeconds > 0 ? expiresInSeconds : null;
            }
        }
        """;

    public const string ServiceCollectionExtension =
    """
        using Microsoft.Extensions.DependencyInjection;
        using Microsoft.Extensions.DependencyInjection.Extensions;
        using Scrutor;
        
        namespace {{namespace}};
        
        public static class {{decoratedName}}ServiceCollection
        {
            public static IServiceCollection Add{{decoratedName}}(this IServiceCollection services)
            {
                {{decoratedRegistration}}
                {{decoratorRegistration}}
                return services;
            }
        }
        """;

    public static string GenerateServiceCollectionExtension(WrappedInfo classInfo)
    {
        var decoratedRegistration = string.IsNullOrWhiteSpace(classInfo.InterfaceName)
            ? $"services.TryAddTransient<{classInfo.Namespace}.{classInfo.Name}>();"
            : $"services.TryAddTransient<{classInfo.InterfaceName}, {classInfo.Namespace}.{classInfo.Name}>();";

        var decoratorRegistration = string.IsNullOrWhiteSpace(classInfo.InterfaceName)
            ? $"services.AddTransient<{classInfo.DecoratedName}>();"
            : $"services.Decorate<{classInfo.InterfaceName}, {classInfo.DecoratedName}>();";
            // : $"services.AddTransient<{classInfo.DecoratedName}>();";

        var template = ServiceCollectionExtension
            .Replace("{{decoratedName}}", classInfo.DecoratedName)
            .Replace("{{decoratedRegistration}}", decoratedRegistration)
            .Replace("{{decoratorRegistration}}", decoratorRegistration)
            .Replace("{{namespace}}", classInfo.Namespace);
        return template;
    }

    public static string GenerateDecoratorWrapper(WrappedInfo classInfo)
    {
        return BuildPartialClassTemplate(classInfo);
    }

    private static string BuildPartialClassTemplate(WrappedInfo classInfo)
    {
        var accessibility = classInfo.Accessibility.ToString().ToLower();
        var ns = classInfo.Namespace;
        var className = !string.IsNullOrWhiteSpace(classInfo.InterfaceName) ? classInfo.InterfaceName : classInfo.Name;
        var cacheDecoratorName = classInfo.DecoratedName;
        var interfaceImplementationBlock = !string.IsNullOrWhiteSpace(classInfo.InterfaceName)
            ? $" : {classInfo.InterfaceName}" : string.Empty;

        var sb = new StringBuilder();

        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"//     This code was generated by CacheDecoratorGenerator at {DateTime.Now:T}.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.Caching.Memory;");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();
        sb.AppendLine($"{accessibility} partial class {cacheDecoratorName}{interfaceImplementationBlock}");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly {className} _inner;");
        sb.AppendLine("     private readonly IMemoryCache _cache;");
        sb.AppendLine();
        sb.AppendLine($"    public {cacheDecoratorName}({className} inner, IMemoryCache cache)");
        sb.AppendLine("    {");
        sb.AppendLine("        _inner = inner;");
        sb.AppendLine("        _cache = cache;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Append all method blocks found for this class
        foreach (var method in classInfo.Methods)
        {
            if (method.MethodName is null) continue;

            // Check if a key argument was provided (default struct equals check)
            var hasKeyArg = method.KeyArgument.HasValue && method.KeyArgument.Value.Name is not null;
            var methodTemplate = hasKeyArg
                ? BuildMethodWithArgumentsTemplate(method)
                : BuildMethodWithNoArgumentsTemplate(method, className!);

            sb.AppendLine(methodTemplate);
        }


        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string BuildMemoryCacheEntryOptions(int? expiresInSeconds)
    {
        if (expiresInSeconds.HasValue)
        {
            // Return a multiline literal already indented to match caller expectations
            return $@"            new MemoryCacheEntryOptions
            {{
                AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds({expiresInSeconds.Value})
            }}";
        }

        return "            new MemoryCacheEntryOptions()";
    }

    // Builds the method block for a given method detail and containing class name
    private static string BuildMethodWithNoArgumentsTemplate(MethodDetail method, string className)
    {
        var methodName = method.MethodName;
        var returnType = method.ReturnType;
        var specificReturnType = method.SpecificReturnType ?? "void";
        var asyncKeyword = method.IsAsync ? "async " : string.Empty;
        var awaitKeyword = method.IsAsync ? "await " : string.Empty;
        var optionsLiteral = BuildMemoryCacheEntryOptions(method.ExpiresInSeconds);

        var sb = new StringBuilder();

        sb.AppendLine($"    public {asyncKeyword}{returnType} {methodName}()");
        sb.AppendLine("    {");
        sb.AppendLine($"        var cacheKey = \"{className}.{methodName}\";");
        sb.AppendLine();
        sb.AppendLine($"        if (_cache.TryGetValue(cacheKey, out {specificReturnType} cached))");
        sb.AppendLine("        {");
        sb.AppendLine("            return cached;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        var result = {awaitKeyword}_inner.{methodName}();");
        sb.AppendLine();
        sb.AppendLine("        _cache.Set(cacheKey, result, ");
        sb.AppendLine(optionsLiteral);
        sb.AppendLine("        );");
        sb.AppendLine();
        sb.AppendLine("        return result;");
        sb.AppendLine("    }");

        return sb.ToString();
    }

    private static string BuildMethodWithArgumentsTemplate(MethodDetail method)
    {
        var methodName = method.MethodName;
        var returnType = method.ReturnType;
        var specificReturnType = method.SpecificReturnType ?? "void";
        var asyncKeyword = method.IsAsync ? "async " : string.Empty;
        var awaitKeyword = method.IsAsync ? "await " : string.Empty;
        var argumentType = method.KeyArgument?.Type ?? "object";
        var argumentName = method.KeyArgument?.Name ?? "arg";
        var optionsLiteral = BuildMemoryCacheEntryOptions(method.ExpiresInSeconds);

        var sb = new StringBuilder();

        sb.AppendLine($"    public {asyncKeyword}{returnType} {methodName}({argumentType} {argumentName})");
        sb.AppendLine("    {");
        sb.AppendLine($"        var cacheKey = {argumentName};");
        sb.AppendLine();
        sb.AppendLine($"        if (_cache.TryGetValue(cacheKey, out {specificReturnType} cached))");
        sb.AppendLine("        {");
        sb.AppendLine("            return cached;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        var result = {awaitKeyword}_inner.{methodName}(cacheKey);");
        sb.AppendLine();
        sb.AppendLine("        _cache.Set(cacheKey, result, ");
        sb.AppendLine(optionsLiteral);
        sb.AppendLine("        );");
        sb.AppendLine();
        sb.AppendLine("        return result;");
        sb.AppendLine("    }");

        return sb.ToString();
    }
}
